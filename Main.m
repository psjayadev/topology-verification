%% A code to identify the error in the topology of a network given its conservation graph and noise-free samples

clc
clear all
noise_flag = 0;
SNR = 0;
Nrepeats = 1;
data_flag = input('<strong> Enter 1 if you want to feed input : \n Enter 2 if you want a random network and data to be generated </strong>\n');
if isempty(data_flag)
    fprintf(2, 'No input given: Random Network will be generated by default\n');
    data_flag = 2;
elseif (data_flag ~= 1 && data_flag ~=2)
    fprintf(2, 'Invalid input: Random Network will be generated by default\n');
    data_flag = 2;
end

if (data_flag ==1)
    fprintf('\n Checking the provision of Incidence matrix of a conservation graph with variable name Inc_g and flow data in the workspace with the variable name X \n');
    test = exist('X','var');
    if test==1
        fprintf(2, 'Flow data provided\n')
    else
        fprintf(2, 'Flow data NOT provided\n')
        return
    end
    test = exist('Inc_g','var');
    if test==0
        fprintf(2, 'Incidence matrix NOT provided\n')
        return
    end

else

    network_flag = input('\n <strong> Enter 1 for Erdos-Renyi Network : Enter 2 for Small World Network : Enter 3 for Scale Free Network </strong> \n');
    if isempty(network_flag)
        fprintf(2, 'No input given: Erdos-Renyi network chosen by default \n');
        network_flag = 1;
    elseif (network_flag ~= 1 && network_flag ~=2 && network_flag ~=3)
        fprintf(2, 'Invalid input: Erdos-Renyi network chosen by default \n');
        network_flag = 1;
    end

    n = input('\n <strong> Choose number of nodes for topology of network to be generated, a value between 10 and 100 </strong> \n');
    if isempty(n)
        fprintf(2,'No input given: Set to default value of 15 \n')
        n=15;
    elseif (n<10 || n>100)
        fprintf(2,'Invalid input: Set to default value of 15 \n');
        n=15;
    end
    
     error_select = input('\n <strong> Choose the topology error to be generated: Enter 1 for swapping edges : Enter 2 for incorrectly specified edge \n : Enter 3 for unspecified edge : Enter 4 for unspecified node </strong> \n');
    if isempty(error_select)
        fprintf(2,'No input given: Error randomly chosen \n');
%         error_select=1;
        error_select = ceil(4*rand());
    elseif (error_select~=1 && error_select~=2)
        fprintf(2,'Invalid input: Error randomly chosen \n');
%         error_select=1;
        error_select = ceil(4*rand());
    end

    % Generating a random network and its conservation graph 
    [Inc_net,sources,sinks,intermediate,Inc_Con,Cc_Con,n_c,e_c,branch,chord,b,c] = Network_Generation(n,network_flag);
    fprintf(2, '\n Randomly generated a network whose conservation graph has %d nodes and %d edges\n',n_c,e_c);


    NSamples = input('\n <strong> For no. of samples, enter an integer >= 1 </strong> \n');
    if isempty(NSamples)
        fprintf(2,'No input given: Set to default value of 1 \n');
        NSamples=1;
    elseif (NSamples<1)
        fprintf(2,'Invalid input: Set to default value of 1 \n');
        NSamples=1;
    else
        NSamples = round(NSamples);
    end

    %% Data generation using random generators
    % Chord flows are independently generated
    % Branch flows are generated from chord flows using cutset equations
    [X,Sigma_e] = Data_Generation(e_c,branch,chord,b,c,Cc_Con,NSamples,SNR,noise_flag,Nrepeats);    

    
    %% Creating an chosen error in the reported topology
    [Inc_rep,necon_rep,necon,nenet,ec_bar,nc_bar,error_nodes_true,error_edges_true] = Error_Generation(Inc_Con,Inc_net,e_c,n_c,error_select);
end

%% Detection and Identification of Topology Error when number of samples are less than n_c
% Checking if the number of edges in the topology and flow data match
if ec_bar~=e_c
    fprintf('Unspecified edge detected \n')
    error_case = 1;
else
% Residual vector and error signature calculation
    res = Inc_rep(2:end,:)*X;
    res_mean = mean(res,2);
    res_min = min(abs(res_mean(abs(res_mean)>0.001))); %Finding the least magnitude non-zero residual in the residual vector 
    error_sig = round(res_mean/res_min); % Finding the error signature
    if ~any(round(res_mean)~=0)
        fprintf('No topology error could be detected \n');
        error_case = 0;
    elseif isequal(sort(nonzeros(error_sig)),[-1;1])
        fprintf('Possibility of Swapped edges (or) Incorrectly specified edge (or) Unspecified node detected \n');
        error_case = 4;
    elseif (isequal(sort(nonzeros(error_sig)),[-1;-1;1;1]) || isequal(sort(nonzeros(error_sig)),[-2;1;1]) || isequal(sort(nonzeros(error_sig)),[-1;-1;2]))
        fprintf('Possibility of Swapped edges (or) Incorrectly specified edge detected \n');
        error_case = 3;
    else 
        fprintf('Possibility of Unspecified node detected \n');
        error_case = 2;
    end
end


%% Isolation and Rectification of Topology Error
if NSamples>1
    meanX = mean(X,1);  % Mean of the flow values along each edge
else
    meanX = X;      % If there is only one sample, then mean is the sample itself
end
if error_case==1            % Unspecified edge
    [Inc_rect,unsp_edge] = unsp_edge_rectify_check(Inc_rep,e_c,ec_bar,nc_bar,X,meanX);
elseif error_case == 2           % Unspecified node
    [Inc_rect] = unsp_node_rectify_check(Inc_rep,e_c,ec_bar,nc_bar,X,meanX,res_mean);
elseif error_case == 3          % Swapped edges (or) Incorrectly specified edge
    % Listing out all possible cases for given error signature
    if any(abs(error_sig)==2)   % Type 2 error in both cases
        error_nodes1 = find(abs(error_sig)==1)';
        error_nodes2 =  find(abs(error_sig)==2)';
        error_nodes = [error_nodes1 error_nodes2];
        error_edges = [];   % Edges involved in any error
        inc_edges = [];     % Incorrectly specified edges
        swap_edges = [];    % Swapped edges
        for i=1:ec_bar
            if any(error_nodes==necon_rep(i,2)) &&  any(error_nodes==necon_rep(i,3)) % Finding the edges that could be involved based on the error signature
                error_edges(end+1,:) = necon_rep(i,:);
                if round(abs(res_mean(necon_rep(i,2)))) == round(abs(meanX(necon_rep(i,1)))) || round(abs(res_mean(necon_rep(i,3)))) == round(abs(meanX(necon_rep(i,1))))   % Checking if the residual mean equals the mean of the flow along the edge
                    inc_edges(end+1,:) = necon_rep(i,:);
                end
            end
        end
        for i=1:size(error_edges,1)
            for j=1:size(error_edges,1)
                if error_edges(i,3)==error_edges(j,2)  % Checking if the edges have a common edge for type 2 swapping
                    if round(abs(res_mean(error_edges(i,2)))) == round(abs(meanX(error_edges(i,1))-meanX(error_edges(j,1)))) && i~=j % Checking if the residual mean equals the difference in mean of the flow along the edge
                        swap_edges(end+1,:) = [error_edges(i,:) error_edges(j,:)];
                    end
                end
            end
        end
        if size(inc_edges,1)+size(swap_edges,1)==1
            if size(inc_edges,1)==1             % Incorrectly specified edge detected
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges,2,meanX);
                Inc_rect = [1:e_c;Inc_rect];       
                if sum(any(round(Inc_rect(2:end,:)*X)))==0
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect',inc_edges(1));
                else
                fprintf('Error isolation and rectification failed.');
                end    
            else   % Swapped edges detected
                Inc_rect = Inc_rep;
                [Inc_rect(2:end,swap_edges(1)),Inc_rect(2:end,swap_edges(4))]=deal(Inc_rect(2:end,swap_edges(4)),Inc_rect(2:end,swap_edges(1)));
                if sum(any(round(Inc_rect(2:end,:)*X)))==0
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect',swap_edges(1),swap_edges(4));
                else
                    fprintf('Error isolation and rectification failed.');
                end
            end
    else     % Multiple possibilities which need to checked further
            inc_edges_checked = []; % Listing the edges after checking if the residual goes to zero after reversal
            swap_checked = []; % Listing the swapped edges after checking if the residual goes to zero after reversal
            for i=1:size(swap_edges,1)
                Inc_rect = Inc_rep;
                [Inc_rect(2:end,swap_edges(1)),Inc_rect(2:end,swap_edges(4))]=deal(Inc_rect(2:end,swap_edges(4)),Inc_rep(2:end,swap_edges(1)));
                if sum(any(round(Inc_rect(2:end,:)*X)))==0
                    swap_checked(end+1,:) = swap_edges(i,:);
                end
            end
            for i=1:size(inc_edges,1)
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges(i,:),2,meanX);
                Inc_rect = [1:e_c;Inc_rect]; 
                if sum(any(round(Inc_rect*X)))==0
                    inc_edges_checked(end+1,:) = inc_edges(i,:);
                end
            end
            if size(inc_edges_checked,1)+size(swap_checked,1)==1
                Inc_rect = [1:e_c;Inc_rect];
                if size(inc_edges_checked,1)==1
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect',inc_edges_checked(1));
                else 
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect',swap_checked(1),swap_checked(4));
                end
            elseif size(inc_edges_checked,1)+size(swap_checked,1)>1     
                fprintf('There are multiple errors that could result in the same residuals and not indistinguishable.');
                fprintf('The list of possible errors are: \n');
                for i=1:size(inc_edges,1)
                    fprintf('Edge: %d could be incorrectly specified \n',inc_edges(i,1));
                end
                for i=1:size(swap_checked,1)
                    fprintf('Edges: %d,%d could have got swapped \n',swap_edges(i,1),swap_edges(i,4));
                end
            else
                fprintf('Error isolation and rectification failed.');
            end
        end
    else   % Type 1 error in both the cases
        error_nodes1 = find(error_sig==1)';
        error_nodes2 = find(error_sig==-1)';
        error_nodes = [error_nodes1 error_nodes2];
        error_edges = [ ];
        inc_edges = [];
        swap_edges = [];
        for i=1:ec_bar
            if (any(error_nodes1==necon_rep(i,2)) &&  any(error_nodes2==necon_rep(i,3)))||(any(error_nodes2==necon_rep(i,2)) && any(error_nodes1==necon_rep(i,3)))
                % Finding the edges that could be involved based on the error signature
                error_edges(end+1,:) = necon_rep(i,:);
                if round(abs(res_mean(necon_rep(i,2)))) == round(abs(meanX(necon_rep(i,1))))   % Checking if the residual mean equals the mean of the flow along the edge
                    inc_edges(end+1,:) = necon_rep(i,:);
                end
            end
        end
        for i=1:size(error_edges,1)
            for j=i+1:size(error_edges,1)
                if (round(abs(res_mean(error_edges(i,2)))) == round(abs(meanX(error_edges(i,1))-meanX(error_edges(j,1))))) && (~any(intersect(error_edges(i,2:3),error_edges(j,2:3)))) 
                    % Checking if the residual mean equals the difference in mean of the flow along the edge
                    % Also checking that the edges have no common nodes
                    swap_edges(end+1,:) = [error_edges(i,:) error_edges(j,:)];
                end
            end
        end
        if size(inc_edges,1)+size(swap_edges,1)==1
            if size(inc_edges,1)==1             % Incorrectly specified edge detected
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges,1,meanX);
                Inc_rect = [1:e_c;Inc_rect];   
                if sum(any(round(Inc_rect(2:end,:)*X)))==0
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect',inc_edges(1));
                else
                    fprintf('Error isolation rectification failed.');
                end
            else   % Swapped edges detected
                Inc_rect = Inc_rep;
                [Inc_rect(2:end,swap_edges(1)),Inc_rect(2:end,swap_edges(4))]=deal(Inc_rect(2:end,swap_edges(4)),Inc_rect(2:end,swap_edges(1)));
                if sum(any(round(Inc_rect(2:end,:)*X)))==0
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect',swap_edges(1),swap_edges(4));
                else
                    fprintf('Error isolation and rectification failed.');
                end
            end
        else     % Multiple possibilities which need to checked further
            inc_edges_checked = []; % Listing the edges after checking if the residual goes to zero after reversal
            swap_checked = []; % Listing the swapped edges after checking if the residual goes to zero after reversal
            for i=1:size(swap_edges,1)
                Inc_rect = Inc_rep(2:end,:);
                [Inc_rect(:,swap_edges(1)),Inc_rect(:,swap_edges(4))]=deal(Inc_rect(:,swap_edges(4)),Inc_rect(:,swap_edges(1)));
                if sum(any(round(Inc_rect*X)))==0
                    swap_checked(end+1,:) = swap_edges(i,:);
                end
            end
            for i=1:size(inc_edges,1)
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges(i,:),1,meanX);
                if sum(any(round(Inc_rect*X)))==0
                    inc_edges_checked(end+1,:) = inc_edges(i,:);
                end
            end
            if size(inc_edges_checked,1)+size(swap_checked,1)==1
                Inc_rect = [1:e_c;Inc_rect];
                if size(inc_edges_checked,1)==1
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect.',inc_edges_checked(1));
                else 
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect.',swap_checked(1),swap_checked(4));
                end
            elseif size(inc_edges_checked,1)+size(swap_checked,1)>1     
                fprintf('There are multiple errors that could result in the same residuals and not indistinguishable.\n');
                fprintf('The list of possible errors are: \n');
                for i=1:size(inc_edges,1)
                    fprintf('Edge: %d could be incorrectly specified \n',inc_edges(i,1));
                end
                for i=1:size(swap_checked,1)
                    fprintf('Edges: %d,%d could have got swapped \n',swap_edges(i,1),swap_edges(i,4));
                end
            else
                fprintf('Error isolation and rectification failed.');
            end
        end
    end
    
    
elseif error_case == 4
    error_nodes1 = find(error_sig==1)';
    error_nodes2 =  find(error_sig==-1)';
    error_nodes = [error_nodes1 error_nodes2];
    error_edges = [];
    inc_edges = [];
    swap_edges = [];
    for i=1:ec_bar
        if any(error_nodes==necon_rep(i,2)) ||  any(error_nodes==necon_rep(i,3)) % Finding the edges that could be involved based on the error signature
            error_edges(end+1,:) = necon_rep(i,:);
            if round(abs(res_mean(necon_rep(i,2)))) == round(abs(meanX(necon_rep(i,1)))) || round(abs(res_mean(necon_rep(i,3)))) == round(abs(meanX(necon_rep(i,1))))  % Checking if the residual mean equals the mean of the flow along the edge
                inc_edges(end+1,:) = necon_rep(i,:);
            end
        end
    end
    for i=1:size(error_edges,1)
        for j=i+1:size(error_edges,1)
            uncommon_node = setdiff(error_edges(i,2:3),error_edges(j,2:3));
            if any(intersect(error_edges(i,2:3),error_edges(j,2:3))) 
                if (round(abs(res_mean(uncommon_node))) == round(abs(meanX(error_edges(i,1))-meanX(error_edges(j,1)))))
                % Checking if the residual mean equals the difference in mean of the flow along the edge
                % Also checking that the edges have a common node
                    swap_edges(end+1,:) = [error_edges(i,:) error_edges(j,:)]; % Type 3 swap
                elseif (round(abs(res_mean(error_edges(i,2)))) == round(2*abs(meanX(error_edges(i,1))-meanX(error_edges(j,1)))))
                    swap_edges(end+1,:) = [error_edges(i,:) error_edges(j,:)]; % Type 4 swap
                end
            end
        end
    end
    % Checking if there is a possibility for unspecified node or not
    temp1 = error_edges(round(abs(meanX(error_edges(:,1))))==(round(abs(res_mean(error_nodes1)))),1);
    temp2 = error_edges(round(abs(meanX(error_edges(:,1))))==(round(abs(res_mean(error_nodes2)))),1);
    if size(union(temp1,temp2),1)<2 
        node_test=0;
    else
        node_test=1;
    end
        if size(inc_edges,1)+size(swap_edges,1)==1
            if size(inc_edges,1)==1             % Incorrectly specified edge detected
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges,34,meanX);
                Inc_rect = [1:e_c;Inc_rect];
                if sum(any(round(Inc_rect(2:end,:)*X)))==0 && node_test==0
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect.',inc_edges(1));
                elseif sum(any(round(Inc_rect(2:end,:)*X)))~=0 && node_test==0
                    fprintf('Error isolation and rectification failed.');
                end
            else   % Swapped edges detected
                Inc_rect = Inc_rep;
                [Inc_rect(:,swap_edges(1)),Inc_rect(:,swap_edges(4))]=deal(Inc_rect(:,swap_edges(4)),Inc_rect(:,swap_edges(1)));
                if sum(any(round(Inc_rect(2:end,:)*X)))==0 && node_test==0
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect.',swap_edges(1),swap_edges(4));
                elseif sum(any(round(Inc_rect(2:end,:)*X)))~=0 && node_test==0
                    fprintf('Error isolation and rectification failed.');
                end
            end
        else  % Multiple possibilities which need to checked further
            inc_edges_checked = []; % Listing the edges after checking if the residual goes to zero after reversal
            swap_checked = []; % Listing the swapped edges after checking if the residual goes to zero after reversal
            for i=1:size(swap_edges,1)
                Inc_rect = Inc_rep(2:end,:);
                [Inc_rect(:,swap_edges(1)),Inc_rect(:,swap_edges(4))]=deal(Inc_rect(:,swap_edges(4)),Inc_rect(:,swap_edges(1)));
                if sum(any(round(Inc_rect*X)))==0
                    swap_checked(end+1,:) = swap_edges(i,:);
                end
            end
            for i=1:size(inc_edges,1)
                [Inc_rect] = inc_edges_rectify(Inc_rep,error_nodes1,error_nodes2,inc_edges(i,:),34,meanX);
                if sum(any(round(Inc_rect*X)))==0
                    inc_edges_checked(end+1,:) = inc_edges(i,:);
                end
            end
            if size(inc_edges_checked,1)+size(swap_checked,1)==1
                Inc_rect = [1:e_c;Inc_rect];
                if size(inc_edges_checked,1)==1 && node_test==0 
                    fprintf('Edge: %d is incorrectly specified. It is rectified and the recitified incidence matrix is Inc_rect',inc_edges_checked(1));
                elseif  size(swap_checked,1)==1 && node_test==0 
                    fprintf('Edges: %d,%d got swapped. The recitified incidence matrix is Inc_rect',swap_checked(1),swap_checked(4));
                end
            elseif size(inc_edges_checked,1)+size(swap_checked,1)>1 || (size(inc_edges_checked,1)+size(swap_checked,1)==1 && node_test==1)     
                fprintf('There are multiple errors that could result in the same residuals and not indistinguishable. \n');
                fprintf('The list of possible errors are: \n');
                for i=1:size(inc_edges_checked,1)
                    fprintf('Edge: %d could be incorrectly specified \n',inc_edges(i,1));
                end
                for i=1:size(swap_checked,1)
                    fprintf('Edges: %d,%d could have got swapped \n',swap_edges(i,1),swap_edges(i,4));
                end
                if node_test==1
                    fprintf('There could be a missing node \n');
                end
            elseif size(inc_edges_checked,1)+size(swap_checked,1)==0 && node_test==1
                [Inc_rect] = unsp_node_rectify_check(Inc_rep,e_c,ec_bar,nc_bar,X,meanX,res_mean);
            else
                fprintf('Error isolation and rectification failed');
            end
        end  
else  % No topology error detected
    fprintf('No topology error detected');
end
error_edges_true
   
            
        
